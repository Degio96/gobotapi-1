// Code AutoGenerated; DO NOT EDIT.

package methods

import (
	"encoding/json"
	"github.com/GoBotApiOfficial/gobotapi/types"
	rawTypes "github.com/GoBotApiOfficial/gobotapi/types/raw"
	"reflect"
)

// SetWebhook Use this method to specify a URL and receive incoming updates via an outgoing webhook
// Whenever there is an update for the bot, we will send an HTTPS POST request to the specified URL, containing a JSON-serialized Update
// In case of an unsuccessful request, we will give up after a reasonable amount of attempts
// Returns True on success.
// If you'd like to make sure that the webhook was set by you, you can specify secret data in the parameter secret_token
// If specified, the request will contain a header “X-Telegram-Bot-Api-Secret-Token” with the secret token as content.
type SetWebhook struct {
	AllowedUpdates     []string                  `json:"allowed_updates,omitempty"`
	Certificate        rawTypes.InputFile        `json:"certificate,omitempty"`
	DropPendingUpdates bool                      `json:"drop_pending_updates,omitempty"`
	IPAddress          string                    `json:"ip_address,omitempty"`
	MaxConnections     int                       `json:"max_connections,omitempty"`
	SecretToken        string                    `json:"secret_token,omitempty"`
	URL                string                    `json:"url"`
	Progress           rawTypes.ProgressCallable `json:"-"`
}

func (entity *SetWebhook) ProgressCallable() rawTypes.ProgressCallable {
	return entity.Progress
}

func (entity *SetWebhook) Files() map[string]rawTypes.InputFile {
	files := make(map[string]rawTypes.InputFile)
	switch entity.Certificate.(type) {
	case types.InputBytes:
		files["certificate"] = entity.Certificate
		entity.Certificate = nil
	}
	return files
}

func (entity SetWebhook) MarshalJSON() ([]byte, error) {
	if reflect.DeepEqual(entity.Certificate, nil) {
		entity.Certificate = nil
	}
	type x0 SetWebhook
	return json.Marshal((x0)(entity))
}

func (SetWebhook) MethodName() string {
	return "setWebhook"
}

func (SetWebhook) ParseResult(response []byte) (*rawTypes.Result, error) {
	var x1 struct {
		Result bool `json:"result"`
	}
	err := json.Unmarshal(response, &x1)
	if err != nil {
		return nil, err
	}
	result := rawTypes.Result{
		Kind:   types.TypeBoolean,
		Result: x1.Result,
	}
	return &result, nil
}
